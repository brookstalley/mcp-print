#!/usr/bin/env python3
"""
Printful-to-MCP bridge (SSE transport).

Required env vars:
  PRINTFUL_API_KEY   - API key from https://developers.printful.com
  AUTH_TOKEN         - Bearer token clients must present
  PORT               - optional (default 8000)
"""

from pathlib import Path
from dotenv import load_dotenv
load_dotenv(Path(__file__).parent / ".env.dev", override = False)  # Load .env file if exists

import inspect
import os
import pkgutil
from importlib import import_module
from typing import Any, Callable, Dict

from fastapi import Depends, Header, HTTPException, status
from fastmcp import FastMCP
from sse_starlette import ServerSentEvent as SseEvent
from printfulv2 import AsyncClient, AuthenticatedClient

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  Security â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_EXPECTED_AUTH = f"Bearer {os.getenv('AUTH_TOKEN', '')}"
if len(_EXPECTED_AUTH) <= 7:
    raise RuntimeError("AUTH_TOKEN env var is missing or empty")

def verify_auth(Authorization: str = Header(...)) -> None:        # noqa: D401
    """Reject requests without the expected Bearer token."""
    if Authorization != _EXPECTED_AUTH:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="invalid bearer token ðŸ¦›",
        )

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  Printful OpenAPI client (async) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

from printful_client import AsyncClient, AuthenticatedClient          # type: ignore
PRINTFUL = AuthenticatedClient(
    base_url="https://api.printful.com",
    token=os.environ["PRINTFUL_API_KEY"],
    timeout=30.0,
    follow_redirects=True,
)
PRINTFUL_ASYNC = AsyncClient(client=PRINTFUL)

class PrintfulInvoker:
    """
    Discovers every async helper generated by *openapi-python-client* and
    dispatches by OpenAPI `operationId`.
    """

    def __init__(self) -> None:
        import printful_client.apis as apis                       # noqa: WPS433

        self._funcs: Dict[str, Callable[..., Any]] = {}
        for _, mod_name, _ in pkgutil.walk_packages(
            apis.__path__, apis.__name__ + "."
        ):
            mod = import_module(mod_name)
            for name, obj in inspect.getmembers(mod):
                if name.endswith("_async") and callable(obj):
                    op_id = getattr(obj, "__operation_id__", None) \
                            or name.removesuffix("_async")
                    self._funcs[op_id] = obj

    async def __call__(self, operation_id: str, **kwargs: Any) -> Any:
        func = self._funcs.get(operation_id)
        if func is None:
            raise HTTPException(status_code=404,
                                detail=f"Unknown Printful op '{operation_id}'")
        # All generated helpers expose `.asyncio(...)`
        return await func.asyncio(client=PRINTFUL_ASYNC, **kwargs)

printful_call = PrintfulInvoker()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  MCP tooling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

mcp = FastMCP("Printful-MCP-Bridge")

@mcp.tool()
async def call_printful(operation_id: str, params: Dict[str, Any] = {}) -> Any:  # noqa: D401
    """
    Invoke **any** Printful endpoint by its `operation_id`.

    Example:
        call_printful("getStores", {})          # List stores
        call_printful("postOrders", {           # Create order
            "store_id": 42,
            "external_id": "hippoâ€‘orderâ€‘1",
            "items": [...],
        })
    """
    return await printful_call(operation_id, **params)

# Convert to FastAPI app with global auth dependency
app = mcp.to_fastapi(dependencies=[Depends(verify_auth)])

# Graceful shutdown: close the underlying HTTP connection pool
@app.on_event("shutdown")
async def _close_printful() -> None:                               # noqa: D401
    await PRINTFUL_ASYNC.aclose()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if __name__ == "__main__":                                         # pragma: no cover
    port = int(os.getenv("PORT", "8000"))
    # FastMCPâ€™s runner wires SSE routes automatically.
    mcp.run(
        transport="sse",  # requirement: SSE transport
        host="0.0.0.0",
        port=port,
        dependencies=[Depends(verify_auth)],
    )
